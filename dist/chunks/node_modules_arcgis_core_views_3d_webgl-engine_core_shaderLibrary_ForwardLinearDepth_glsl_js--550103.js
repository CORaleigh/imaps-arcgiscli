/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkimaps_redux"] = self["webpackChunkimaps_redux"] || []).push([["node_modules_arcgis_core_views_3d_webgl-engine_core_shaderLibrary_ForwardLinearDepth_glsl_js--550103"],{

/***/ "./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ForwardLinearDepth\": () => (/* binding */ a)\n/* harmony export */ });\n/* harmony import */ var _shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaderModules/interfaces.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/interfaces.js\");\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.18/esri/copyright.txt for details.\n*/\nfunction a(a,r){0===r.output&&r.receiveShadows?(a.varyings.add(\"linearDepth\",\"float\"),a.vertex.code.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n      void forwardLinearDepth() { linearDepth = gl_Position.w; }\n    `)):1===r.output||3===r.output?(a.varyings.add(\"linearDepth\",\"float\"),a.vertex.uniforms.add(\"uCameraNearFar\",\"vec2\"),a.vertex.code.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n      void forwardLinearDepth() {\n        linearDepth = (-position_view().z - uCameraNearFar[0]) / (uCameraNearFar[1] - uCameraNearFar[0]);\n      }\n    `)):a.vertex.code.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n      void forwardLinearDepth() {}\n    `)}\n\n\n//# sourceURL=webpack://imaps-redux/./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js?");

/***/ }),

/***/ "./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnalyticalSkyModel\": () => (/* binding */ t)\n/* harmony export */ });\n/* harmony import */ var _shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shaderModules/interfaces.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/interfaces.js\");\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.18/esri/copyright.txt for details.\n*/\nfunction t(t){const a=t.fragment.code;a.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)\n    {\n      return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;\n    }\n    `),a.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    float integratedRadiance(float cosTheta2, float roughness)\n    {\n      return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);\n    }\n    `),a.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)\n    {\n      float cosTheta2 = 1.0 - RdotNG * RdotNG;\n      float intRadTheta = integratedRadiance(cosTheta2, roughness);\n\n      // Calculate the integrated directional radiance of the ground and the sky\n      float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;\n      float sky = 2.0 - ground;\n      return (ground * ambientGround + sky * ambientSky) * 0.5;\n    }\n    `)}\n\n\n//# sourceURL=webpack://imaps-redux/./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js?");

/***/ }),

/***/ "./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhysicallyBasedRendering\": () => (/* binding */ n)\n/* harmony export */ });\n/* harmony import */ var _shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shaderModules/interfaces.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/interfaces.js\");\n/* harmony import */ var _PiUtils_glsl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PiUtils.glsl.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\");\n/* harmony import */ var _AnalyticalSkyModel_glsl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnalyticalSkyModel.glsl.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js\");\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.18/esri/copyright.txt for details.\n*/\nfunction n(n,a){const r=n.fragment.code;n.include(_PiUtils_glsl_js__WEBPACK_IMPORTED_MODULE_1__.PiUtils),3===a.pbrMode||4===a.pbrMode?(r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    struct PBRShadingWater\n    {\n        float NdotL;   // cos angle between normal and light direction\n        float NdotV;   // cos angle between normal and view direction\n        float NdotH;   // cos angle between normal and half vector\n        float VdotH;   // cos angle between view direction and half vector\n        float LdotH;   // cos angle between light direction and half vector\n        float VdotN;   // cos angle between view direction and normal vector\n    };\n\n    float dtrExponent = ${a.useCustomDTRExponentForWater?\"2.2\":\"2.0\"};\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    vec3 fresnelReflection(float angle, vec3 f0, float f90) {\n      return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n    }\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    float normalDistributionWater(float NdotH, float roughness)\n    {\n      float r2 = roughness * roughness;\n      float NdotH2 = NdotH * NdotH;\n      float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n      return r2 / denom;\n    }\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    float geometricOcclusionKelemen(float LoH)\n    {\n        return 0.25 / (LoH * LoH);\n    }\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max)\n    {\n      vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n      float dSun = normalDistributionWater(props.NdotH, roughness);\n      float V = geometricOcclusionKelemen(props.LdotH);\n\n      float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);\n      float strengthSunHaze  = 1.2;\n      float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze)*strengthSunHaze;\n\n      return ((dSun + dSunHaze) * V) * F;\n    }\n\n    vec3 tonemapACES(const vec3 x) {\n      return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n    }\n    `)):1!==a.pbrMode&&2!==a.pbrMode||(n.include(_AnalyticalSkyModel_glsl_js__WEBPACK_IMPORTED_MODULE_2__.AnalyticalSkyModel),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    struct PBRShadingInfo\n    {\n        float NdotL;                  // cos angle between normal and light direction\n        float NdotV;                  // cos angle between normal and view direction\n        float NdotH;                  // cos angle between normal and half vector\n        float VdotH;                  // cos angle between view direction and half vector\n        float LdotH;                  // cos angle between view light direction and half vector\n        float NdotNG;                 // cos angle between normal and normal of the ground\n        float RdotNG;                 // cos angle between view direction reflected of the normal and normal of the ground\n        float NdotAmbDir;             // cos angle between view direction and the fill light in ambient illumination\n        float NdotH_Horizon;          // cos angle between normal and half vector defined with horizon illumination\n        vec3 skyRadianceToSurface;         // integrated radiance of the sky based on the surface roughness (used for specular reflection)\n        vec3 groundRadianceToSurface;      // integrated radiance of the ground based on the surface roughness (used for specular reflection)\n        vec3 skyIrradianceToSurface;       // irradiance of the sky (used for diffuse reflection)\n        vec3 groundIrradianceToSurface;    // irradiance of the ground (used for diffuse reflection)\n\n        float averageAmbientRadiance;      // average ambient radiance used to deduce black level in gamut mapping\n        float ssao;                   // ssao coefficient\n        vec3 albedoLinear;            // linear color of the albedo\n        vec3 f0;                      // fresnel value at normal incident light\n        vec3 f90;                     // fresnel value at 90o of incident light\n\n        vec3 diffuseColor;            // diffuse color of the material used in environment illumination\n        float metalness;              // metalness of the material\n        float roughness;              // roughness of the material\n    };\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    float normalDistribution(float NdotH, float roughness)\n    {\n        float a = NdotH * roughness;\n        float b = roughness / (1.0 - NdotH * NdotH + a * a);\n        return b * b * INV_PI;\n    }\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    const vec2 c2 = vec2(-1.04, 1.04);\n\n    vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {\n        vec4 r = roughness * c0 + c1;\n        float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;\n        return c2 * a004 + r.zw;\n    }\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {\n      vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);\n      vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);\n\n      // From diffuse illumination calculate reflected color\n      vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;\n\n      // From specular illumination calculate reflected color\n      vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);\n      vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;\n      vec3 specularComponent = specularColor * indirectSpecular;\n\n      return (diffuseComponent + specularComponent);\n    }\n    `),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    float gamutMapChanel(float x, vec2 p){\n      return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );\n    }`),r.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){\n      vec3 outColor;\n      vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));\n      outColor.x = gamutMapChanel(inColor.x, p) ;\n      outColor.y = gamutMapChanel(inColor.y, p) ;\n      outColor.z = gamutMapChanel(inColor.z, p) ;\n      return outColor;\n    }\n    `))}\n\n\n//# sourceURL=webpack://imaps-redux/./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js?");

/***/ }),

/***/ "./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReadShadowMap\": () => (/* binding */ i)\n/* harmony export */ });\n/* harmony import */ var _shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shaderModules/interfaces.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/interfaces.js\");\n/* harmony import */ var _util_RgbaFloatEncoding_glsl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/RgbaFloatEncoding.glsl.js */ \"./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\");\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.18/esri/copyright.txt for details.\n*/\nfunction i(i){i.fragment.include(_util_RgbaFloatEncoding_glsl_js__WEBPACK_IMPORTED_MODULE_1__.RgbaFloatEncoding),i.fragment.uniforms.add(\"depthTex\",\"sampler2D\"),i.fragment.uniforms.add(\"shadowMapNum\",\"int\"),i.fragment.uniforms.add(\"shadowMapDistance\",\"vec4\"),i.fragment.uniforms.add(\"shadowMapMatrix\",\"mat4\",4),i.fragment.uniforms.add(\"depthHalfPixelSz\",\"float\"),i.fragment.code.add(_shaderModules_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.glsl`\n    float readShadowMap(const in vec3 _vpos, float _linearDepth) {\n      float halfPixelSize = depthHalfPixelSz;\n      vec4 distance = shadowMapDistance;\n      float depth = _linearDepth;\n\n      //choose correct cascade\n      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\n\n      if (i >= shadowMapNum) { return 0.0; }\n\n      mat4 mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\n\n      vec4 lv = mat * vec4(_vpos, 1.0);\n      lv.xy /= lv.w;\n\n      // vertex completely outside? -> no shadow\n      vec3 lvpos = 0.5 * lv.xyz + vec3(0.5);\n      if (lvpos.z >= 1.0) { return 0.0; }\n      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\n\n      // calc coord in cascade texture\n      vec2 uv = vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;\n\n      float texSize = 0.5 / halfPixelSize;\n\n      // filter, offset by half pixels\n      vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);\n\n      float s00 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s10 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, -halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s11 = rgba2float(texture2D(depthTex, uv + vec2(halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n      float s01 = rgba2float(texture2D(depthTex, uv + vec2(-halfPixelSize, halfPixelSize))) < lvpos.z ? 1.0 : 0.0;\n\n      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n    }\n  `)}!function(e){e.bindUniforms=function(e,a,i){a.shadowMappingEnabled&&(a.shadowMap.bind(e,i),a.shadowMap.bindView(e,a.origin))},e.bindViewCustomOrigin=function(e,a,i){a.shadowMappingEnabled&&a.shadowMap.bindView(e,i)},e.bindView=function(e,a){a.shadowMappingEnabled&&a.shadowMap.bindView(e,a.origin)}}(i||(i={}));\n\n\n//# sourceURL=webpack://imaps-redux/./node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js?");

/***/ })

}]);